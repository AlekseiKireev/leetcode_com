https://leetcode.com/problems/move-zeroes/

https://walkccc.me/LeetCode/problems/0283/

https://github.com/AlekseiKireev/leetcode_com/tree/main/27.%20Remove%20Element --> https://github.com/AlekseiKireev/leetcode_com/tree/main/283.%20Move%20Zeroes

27. Remove Element : val = 0 AND swap --> 283. Move Zeroes | 283. Move Zeroes: remove swap --> 27. Remove Element 
___

Можно встретить подзадачу:  дается массив из 0 и 1. Нужно за один проход поставить все нули в начало массива. 

решается аналогичным образом как one_traversal.cpp, где вместо if (nums[cur] != 0) { надо положить if (nums[cur] == 0) {
________

Имеет место очевидная формула: $LastIdxNotZero + CountZero = i$, где

$i$ - индекс $nums$

$CountZero$ - количество нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

$LastIdxNotZero$ - количество НЕ нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

Примечательно, что решение my_code_with_CountZero.cpp схоже с my_code_without_unique.cpp задачи 26. Remove Duplicates from Sorted Array
________

283c.cpp == my_code_with_CountNOTZero.cpp

[Разбор задачи 283 leetcode.com Move Zeroes. Решение на C++](https://www.youtube.com/watch?v=oIJ5qG1CPz0)

0. Сортировка пузырьком

Как не надо делать:

O(N^2)

Бежим по массиву, когда встречаем не ноль - начинаем его двигать влево, обменивая с нулём слева от него, пока не станет, что нуля слева нет.

[0,1,0,3,12]

[1,0,0,3,12]

[1,0,3,0,12]

[1,3,0,0,12]

[1,3,0,12,0]

[1,3,12,0,0]

Худший случай - когда ненулевых элементов N/2 и они все в конце - каждый придётся двигать примерно на N/2, итого (N/2)^2 ~ O(N^2)


N=10^6 действий .10^12.

1. 0(N) решение 1 - обмен элементов.

Нужно помнить, где первый ноль. Идём по массиву, встречаем ненулевой элемент - обмениваем его спервым нулем

Первые ненулевые элементы: или пропустить отдельным циклом, или обменять с собой.

\* == куда пишем  
^ == откуда читаем

|   	| * 	|   	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	| ^ 	|   	|   	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	| ^  	|   	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	| ^ 	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|  	  | * 	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^   |   	|

|   	|   	|  	  | * 	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|     | ^  	|

Количество действий: O(N)

Чтений: N  
Обменов: nonzero

Если один обмен - это три присваивания - то присваиваний в худшем случае 3N.

Этот вариант очень хорош, когда нулей много.

2. Всё то же самое, как и в варианте 1, но присваиваем, а не обмениваем, а в конце зануляем хвост массива.

|   	| * 	|   	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	| ^ 	|   	|   	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	| ^  	|   	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	| ^  	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^  	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^  	|   	|

|   	|   	|   	|   	| *  	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	| *  	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	| *  	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	| *  	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	|   	| *  	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

Чтений: N  
Присваиваний: N

Сравнение способов 1 и 2.   
1 
- лучше, если nonzero * 3 < N   
- не хуже, если обмен "стоит" столько же, сколько присваивание.     

2
 - лучше, если обмен лучше чем за 2-3 присваивания не сделать и при этом нулей в массиве мало. 
_________

Здравствуйте! Огромное вам спасибо за разбор задач! Только начинаю вникать в тему программирования и поэтому возникает куча "почему" и "как". У меня возник вопрос по задаче 283 вариант с: в строке 11 у нас происходит вроде не присваивание, а копирование значения элемента a[i]?! Чтобы произвести присваивание стоит, наверное, использовать move? С ним у меня показатели по времени и памяти вроде лучше, чем без него. Буду благодарна вам за обратную связь.

std::move для int'ов не делает вообще ничего. Она облегчает перенос для чего-то, у чего внутренность лежит в динамической памяти. Тогда приёмник может получить ссылку на внутренность того, откуда идёт перенос. И тогда реально копирования основной части данных не происходит. Например в vector, map и похожих контейнерах. Нужно всего лишь понимать как контейнеры внутри устроены. Например у std::array нет указателей внутри - и std::move для него ничего не сможет сделать. Как и для любого элементарного типа, как и для структуры без указателей. Однако если структура с указателями создана Вами лично, то опять же недостаточно написать move, нужно ещё и методы обработки написать - move constructor, move assignment operator.


